function [retval] = HoldAndDetectConstant(data_struct, input)
% Main matlab online function for HADC8
%
%  MH 100115: created
%  MH 130107: refactored into new expt* functions.
% call: exptSetupBridge, exptProcessBridgeInput, do your own thing, then exptRunSubfunctions

if nargin < 2,
    input = [];
    input.saveTime = datestr(now, 'yymmdd-HHMM'); 
end

ds = data_struct;
addpath('~/Repositories/BehaviorCode-Glickfeld-Hull/BehaviorCode/Old-maunsell/MatlabSharedCode');
addpath('~/Repositories/BehaviorCode-Glickfeld-Hull/BehaviorAnalysis');

varsOneValEachTrial = {...
    'tTotalRewardTimeUs', ...
    'tFakeMouseReactMs', ...
    'tStartTrialWaitForPressTimeMs', ...
    'tConsecErrors', ...
    'tConsecTimeoutStartTime', ...
    'tNRewards', ...
    'tInterRewardIntervalMs', ...
    'tRewardAddPerMsHoldUs', ...
    'tStimTurnedOn', ...
    'tItiWaitTimeMs', ...
    'tThisTrialStartTimeMs', ...
    'tLastTrialStartTimeMs', ...
    'tTempStimOdds', ...
    'tStimulusNumber', ...
    'tSvStimNumber', ...
    'tSvCatchNumber', ... 
    'tCycleLaser', ...   
    'tLaserPowerMw', ...
    'tLaserDoLinearRamp', ...
    'tLaserDoPulseTrain', ...
    'tLaserRampLengthMs', ...
    'tLaserPeakMaxMw', ...
    'tLaserBaselinePowerMw', ...
    'tGratingMaxContrastStep', ...
    'tGratingContrastStepsPerOctave', ...
    'tGratingMaxDirectionStepDeg', ...
    'tGratingDirectionStepsPerOctave', ...
    'tSoundMaxTargetAmplitude', ...
    'tSoundTargetStepsPerOctave', ...
    'tLaserPeakStepsPerOctave', ...
    'tBaseGratingContrast', ...
    'tBaseGratingDirectionDeg', ...
    'tGratingContrast', ...
    'tGratingDirectionDeg', ...
    'tGratingElevationDeg', ...
    'tGratingAzimuthDeg', ...
    'tGratingHeightDeg', ...
    'tGratingWidthDeg', ...
    'tGratingSpatialFreqCPD', ...
    'tGratingSpeedDPS', ...
    'tTrialLaserPowerMw', ...
    'tTrialLaserPowerMw_trigger',...
    'tTrialLaserOnTimeMs', ...
    'tTrialLaserOffTimeMs', ...
    'tBlock2TrialNumber', ...
    'tNStimAccepted', ...
    'tLeverPressTimeMs', ...
    'tLeverReleaseTimeMs', ...
    'tCyclesOn', ...
    'nCyclesOn', ...
    'tStimOnMs', ...
    'tStimTurnedOn',...
    'targetStimOnMs', ...
    'targetStimOn2Ms', ...
    'tStimOffMs', ...
    'startReactState',...
    'stimTag',...
    'isTooFast',...
    'isCatchTrial',...
    'catchCyclesOn',...
    'tShortCatchTrial',...
    'tFalseAlarm',...
    'tCatchTimeMs',...
    'tCatchGratingDirectionDeg',...
    'tCatchGratingContrast',...
    'tDoAuditoryDetect',...
    'tDoAuditoryCue',...
    'tDoNoResponse',...
    'tSoundCatchAmplitude',...
    'tDoCatchAuditoryDetect',...
    'tSoundTargetAmplitude', ...
    'tStimOnTimeMs', ...
    'tStimOffTimeMs', ...
    'tTargetOnTimeMs', ...
    'tMinCyclesOn', ...
    'tMaxCyclesOn', ...
    'tTotalStimTimeMs', ...
    'tDoTargetAfterMissed', ...
    'tMissedFirstTarget', ...
    'tMissedSecondTarget', ...
    'multVal', ...
    'multValSize'
};

exptSetupBridge;

[input eventsConsts eventsTrial] ...
    = exptProcessBridgeInput(data_struct, input, varsOneValEachTrial);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

trN = input.trialSinceReset;

%% process reaction times for this trial
stimOnUs = mwGetEventTime(eventsTrial, ds.event_codec, 'stimulusOn', 1);

%trialStartUs = mwGetEventTime(eventsTrial, ds.event_codec, 'trialStart', 1);
leverDownUs = mwGetEventTime(eventsTrial, ds.event_codec, 'leverResult', 1, 1);
leverUpUs = mwGetEventTime(eventsTrial, ds.event_codec, 'leverResult', 2, 0);

%calculate cycle duration
totalCycleTimeMs = input.tStimOnTimeMs{trN} + input.tStimOffTimeMs{trN};
numberCyclesOn = input.nCyclesOn{trN};

reqHoldTimeMs = double(totalCycleTimeMs*numberCyclesOn);

holdTimeMs = double((leverUpUs - leverDownUs)) / 1000;
reactTimeMs = double(holdTimeMs - reqHoldTimeMs);

if isfield(input, 'doRandStimOffTime') 
    if input.doRandStimOffTime == 1
        totalStimTime = input.tTotalStimTimeMs{trN};
        nCyclesRemaining = numberCyclesOn - input.tCyclesOn{trN};
        avgCycleTime = ((input.maxStimOffTimeMs+input.minStimOffTimeMs)./2) + input.stimOnTimeMs;
        reqHoldTimeMs = totalStimTime + (nCyclesRemaining*avgCycleTime);
        reactTimeMs = double(holdTimeMs - reqHoldTimeMs);
        tempTimes = mwGetEventValue(eventsTrial, ds.event_codec, 'tStimOffTimeMs', 'all', 1);
        input.tStimOffTimes{trN} = tempTimes(2:end);
    end
end

%track contrast by presentation
if input.doRandCon
    multVals = mwGetEventValue(eventsTrial, ds.event_codec, 'multVal', 'all', 1);
    if input.doLogCon == 0
        input.tBaseGratingContrast{trN} = double(input.baseGratingContrast) + (double(multVals) .* double(input.conDiff));
    elseif input.doLogCon == 1 
        input.tBaseGratingContrast{trN} = double(input.baseGratingContrast) * (2.^double(multVals));
    end
end

%track size by presentation
if input.doRandSize
    multValSizes = mwGetEventValue(eventsTrial, ds.event_codec, 'multValSize', 'all', 1);
    if input.doLogSize == 0
        input.tGratingDiameterDeg{trN} = double(input.gratingHeightDeg) + (double(multValSizes) .* double(input.sizeDiff));
    elseif input.doLogSize == 1 
        input.tGratingDiameterDeg{trN} = double(input.gratingHeightDeg) * (2.^double(multValSizes));
    end
end

% add to array
input.holdStartsMs{trN} = leverDownUs/1000;
input.holdTimesMs{trN} = holdTimeMs;
input.reactTimesMs{trN} = reactTimeMs;
input.tTotalReqHoldTimeMs{trN} = reqHoldTimeMs;
input.leverDownTimeMs{trN} = leverDownUs/1000;
input.leverUpTimeMs{trN} = leverUpUs/1000;


% backward compat
input.gratingContrast = input.tGratingContrast;
input.laserPowerMw = input.tLaserPowerMw;
input.gratingDirectionDeg = input.tGratingDirectionDeg;

% short catch trial calculations
if input.tShortCatchTrial{trN}
    if input.tFalseAlarm{trN}
        input.catchTrialOutcomeCell{trN} = 'FA';
    end
    if isempty(input.tCatchTimeMs{trN})
        input.tCatchTimeMs{trN} = NaN;
        input.catchTrialOutcomeCell{trN} = 'failure';
    end
    if (input.leverUpTimeMs{trN}-input.tCatchTimeMs{trN})>input.reactTimeMs
        input.catchTrialOutcomeCell{trN} = 'CR';
    end
    if (input.leverUpTimeMs{trN}-input.tCatchTimeMs{trN})<input.tooFastTimeMs
        input.catchTrialOutcomeCell{trN} = 'failure';
    end
else
    input.catchTrialOutcomeCell{trN} = 'NaN';
end

try
    input.wheelSpeedTimesUs{trN} = mwGetEventTime(ds.events, ds.event_codec, 'wheelSpeed', 'all', [], 1);
    input.wheelSpeedValues{trN} = mwGetEventValue(ds.events, ds.event_codec, 'wheelSpeed', 'all', 1) ;
catch
    input.wheelSpeedTimesUs{trN} = NaN;
    input.wheelSpeedValues{trN} = NaN;
end

%Andrew's Post-Hoc Reaction Time Method
% if input.targetStimOnMs{trN} <= 1;
%     tCyclesShort = input.nCyclesOn{trN} - input.tCyclesOn{trN};
%     input.targetStimOnMs{trN} = input.tStimOnMs{trN} + (totalCycleTimeMs*tCyclesShort);
% end
% input.postHocReactMs{trN} = input.tLeverReleaseTimeMs{trN} - input.targetStimOnMs{trN};


%% disp status
juiceAmtsMs = input.juiceTimesMsCell{trN};
juiceD = sum(juiceAmtsMs);  % if isempty, this will be empty
nJ = length(juiceAmtsMs);
stimStr = '';
if input.tBlock2TrialNumber{trN} == 0
    if input.doVisualStim
        if input.doContrastDetect
            if input.targetOnTimeMs > 0 
                stimStr = [stimStr sprintf('ctst chg %g%% ', chop(abs(double(input.gratingContrast{trN})-double(input.tBaseGratingContrast{trN})),2)*100)];
            end
            if input.targetOnTimeMs == 0
                x = input.tBaseGratingContrast{trN};
                stimStr = [stimStr sprintf('ctst chg %g%% ', chop(abs(double(x(1))),2)*100)];
            end
        elseif input.doOriDetect
            stimStr = [stimStr sprintf('direction %g%deg ', chop(input.gratingDirectionDeg{trN},2))];
        end
    end
    if input.doPairedPulse
        stimStr = [stimStr ', ' sprintf('stimOffMs %g%ms ', input.tStimOffTimeMs{trN})];
    end
    if input.doAuditoryStim
        if input.doAuditoryDetect
            stimStr = [stimStr ', ' sprintf(' tone vol %g%% ', chop(abs(double(input.tSoundTargetAmplitude{trN})*100),2))];
        end
    end
    if input.doLaserStim
      stimStr = [stimStr sprintf('power %gmW ', ...
                        chop(input.laserPowerMw{trN}, 2))];
    end
else
    if input.block2DoVisualStim
        if input.block2DoContrastDetect
            stimStr = [stimStr sprintf('ctst chg %g%% ', chop(abs(double(input.gratingContrast{trN})-double(input.tBaseGratingContrast{trN})),2)*100)];
        elseif input.block2DoOriDetect
            stimStr = [stimStr sprintf('direction %g%deg ', chop(input.gratingDirectionDeg{trN},2))];
        elseif input.doContrastDetect
            stimStr = [stimStr sprintf('ctst chg %g%% ', chop(abs(double(input.gratingContrast{trN})-double(input.tBaseGratingContrast{trN})),2)*100)];
        elseif input.doOriDetect
            stimStr = [stimStr sprintf('direction %g%deg ', chop(input.gratingDirectionDeg{trN},2))];
        end
    end
    if input.block2DoAuditoryStim
        if input.block2DoAuditoryDetect
            stimStr = [stimStr sprintf(' tone vol %g%%, ', chop(abs(double(input.tSoundTargetAmplitude{trN})*100),2))];
        end
    end
end

if ~input.doBlock2
  block2Str = '';
else
  block2Str = sprintf(' b2tr %d ', input.tBlock2TrialNumber{trN});
end
itiStr = sprintf('iti %d, ', round(input.tItiWaitTimeMs{trN}));
fprintf(1,'Trial# %d, Hold %d, req %d, react %d, %s %s- %d rew %dms\n', ...
        trN, round(holdTimeMs), round(input.tTotalReqHoldTimeMs{trN}), round(reactTimeMs), ...
        stimStr, block2Str, ...
        nJ, round(juiceD));

%% run subfunctions
input = exptRunSubfunctions(ds, input, { @plotFlashingStim });



%% save variables for next trial
retval = input;

return


