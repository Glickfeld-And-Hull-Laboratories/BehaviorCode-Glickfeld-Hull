function [retval] = MovingDotDetect(data_struct, input)
% Main matlab online function for HADC8
%
%  MH 100115: created
%  MH 130107: refactored into new expt* functions.
% call: exptSetupBridge, exptProcessBridgeInput, do your own thing, then exptRunSubfunctions

if nargin < 2,
    input = [];
    input.saveTime = datestr(now, 'yymmdd-HHMM'); 
end

ds = data_struct;
addpath('~/Repositories/BehaviorCode-Glickfeld-Hull/BehaviorCode/NewSkeletonCode/MatlabSharedCode');

varsOneValEachTrial = {...
    'tTotalReqHoldTimeMs', ...
    'tTotalReqHoldFrames', ...
    'tTotalRewardTimeUs', ...
    'tRandReqHoldTimeMs', ...
    'tFakeMouseReactMs', ...
    'tStartTrialWaitForPressTimeMs', ...
    'tConsecErrors', ...
    'tConsecTimeoutStartTime', ...
    'tNRewards', ...
    'tInterRewardIntervalMs', ...
    'tRewardAddPerMsHoldUs', ...
    'tItiWaitTimeMs', ...
    'tItiWaitFrames', ...
    'tThisTrialStartTimeMs', ...
    'tLastTrialStartTimeMs', ...
    'tTempStimOdds', ...
    'tStimulusNumber', ...
    'tSvStimNumber', ...
    'tLaserPowerMw', ...
    'tLaserDoLinearRamp', ...
    'tLaserDoPulseTrain', ...
    'tLaserRampLengthMs', ...
    'tLaserPeakMaxMw', ...
    'tLaserBaselinePowerMw', ...
    'tDotMaxSpeedStepDPS', ...
    'tDotSpeedStepsPerOctave', ...
    'tDotMaxCoherenceStep', ...
    'tDotCoherenceStepsPerOctave', ...
    'tLaserPeakStepsPerOctave', ...
    'tBaseDotContrast', ...
    'tBaseDotSpeedDPS', ...
    'tBaseDotCoherence', ...
    'tDotContrast', ...
    'tDotDirectionDeg', ...
    'tDotElevationDeg', ...
    'tDotAzimuthDeg', ...
    'tDotSizeDeg', ...
    'tDotFieldSizeDeg', ...
    'tDotSpeedDPS', ...
    'tDotCoherence', ...
    'tTrialLaserPowerMw', ...
    'tTrialLaserOnTimeMs', ...
    'tTrialLaserOffTimeMs', ...
    'tBlock2TrialNumber', ...
    'tNStimAccepted', ...
    'tLeverPressTimeMs', ...
    'tLeverReleaseTimeMs', ...
    'tSoundTargetAmplitude', ...
    'cLeverDown', ...
    'cItiStart', ...
    'cLeverUp', ...
    'cTargetOn', ...
};

exptSetupBridge;

[input eventsConsts eventsTrial] ...
    = exptProcessBridgeInput(data_struct, input, varsOneValEachTrial);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

trN = input.trialSinceReset;

%% process reaction times for this trial
stimOnUs = mwGetEventTime(eventsTrial, ds.event_codec, 'stimulusOn', 1);

%trialStartUs = mwGetEventTime(eventsTrial, ds.event_codec, 'trialStart', 1);
leverDownUs = mwGetEventTime(eventsTrial, ds.event_codec, 'leverResult', 1, 1);
leverUpUs = mwGetEventTime(eventsTrial, ds.event_codec, 'leverResult', 2, 0);

totalHoldTimeMs = input.tTotalReqHoldTimeMs{trN};
holdTimeMs = (leverUpUs - leverDownUs) / 1000;
reactTimeMs = (holdTimeMs - totalHoldTimeMs);

% add to array
input.holdStartsMs{trN} = leverDownUs/1000;
input.holdTimesMs{trN} = holdTimeMs;
input.reactTimesMs{trN} = reactTimeMs;
input.leverDownTimeMs{trN} = leverDownUs/1000;
input.leverUpTimeMs{trN} = leverUpUs/1000;


% backward compat
input.laserPowerMw = input.tLaserPowerMw;


%% disp status
juiceAmtsMs = input.juiceTimesMsCell{trN};
juiceD = sum(juiceAmtsMs);  % if isempty, this will be empty
nJ = length(juiceAmtsMs);
stimStr = '';
if input.tBlock2TrialNumber{trN} == 0
    if input.doVisualStim
        if input.doSpeedDetect
            stimStr = [stimStr sprintf('speed chg %g%dps ', chop(abs(double(input.tDotSpeedDPS{trN})-double(input.tBaseDotSpeedDPS{trN})),2))];
        elseif input.doDirDetect
            stimStr = [stimStr sprintf('direction %g%deg coherence chg %g%% ', chop(input.tDotDirectionDeg{trN},2), chop(abs(double(input.tDotCoherence{trN})-double(input.tBaseDotCoherence{trN})),2))];
        end
    end
    if input.doLaserStim
      stimStr = [stimStr sprintf('power %gmW ', ...
                        chop(input.laserPowerMw{trN}, 2))];
    end
else
    if input.block2DoVisualStim
        if input.block2DoSpeedDetect
            stimStr = [stimStr sprintf('speed chg %g%dps ', chop(abs(double(input.tDotSpeedDPS{trN})-double(input.tBaseDotSpeedDPS{trN})),2))];
        elseif input.block2DoDirDetect
            stimStr = [stimStr sprintf('direction %g%deg coherence chg %g%%', chop(input.tDotDirectionDeg{trN},2), chop(abs(double(input.tDotCoherence{trN})-double(input.tBaseDotCoherence{trN})),2))];
        end
    end
end

%% Counter/Frames Synchronization Section
try
    input.counterTimesUs{trN} = mwGetEventTime(eventsTrial, ds.event_codec, 'counter', 'all', [], 1);
    input.counterValues{trN} = mwGetEventValue(eventsTrial, ds.event_codec, 'counter', 'all', 1) ;
catch
    input.counterTimesUs{trN} = NaN;
    input.counterValues{trN} = NaN;
end

try
    input.quadratureTimesUs{trN} = mwGetEventTime(ds.events, ds.event_codec, 'quadrature', 'all', [], 1);
    input.quadratureValues{trN} = mwGetEventValue(ds.events, ds.event_codec, 'quadrature', 'all', 1) ;
catch
    input.quadratureTimesUs{trN} = NaN;
    input.quadratureValues{trN} = NaN;
end

try
    input.wheelSpeedTimesUs{trN} = mwGetEventTime(ds.events, ds.event_codec, 'wheelSpeed', 'all', [], 1);
    input.wheelSpeedValues{trN} = mwGetEventValue(ds.events, ds.event_codec, 'wheelSpeed', 'all', 1) ;
catch
    input.wheelSpeedTimesUs{trN} = NaN;
    input.wheelSpeedValues{trN} = NaN;
end

if ~input.doBlock2
  block2Str = '';
else
  block2Str = sprintf(' b2tr %d ', input.tBlock2TrialNumber{trN});
end
itiStr = sprintf('iti %d, ', round(input.tItiWaitTimeMs{trN}));
fprintf(1,'Hold %d, req %d, react %d, %s %s- %d rew %dms\n', ...
        round(holdTimeMs), round(input.tTotalReqHoldTimeMs{trN}), round(reactTimeMs), ...
        stimStr, block2Str, ...
        nJ, round(juiceD));

%% run subfunctions
input = exptRunSubfunctions(ds, input, { @plotMovingDots });



%% save variables for next trial
retval = input;

return


